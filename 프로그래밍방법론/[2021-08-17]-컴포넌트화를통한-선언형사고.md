# 토글 버튼 추상화 하기

<br>

토글 버튼을 추상화 하여 다른 로직들과 분리 시켜보자. 추상화 한다는 의미는 마치 리액트에서 사용하는 컴포넌트를 만드는 것과 비슷하다고 보면 된다. 코드로 바로 확인해보자

<br>

```js
function ToggleButton({ $target, text }) {
  const $button = document.createElement('button');
  let isInit = false;

  this.render = () => {
    $button.textContent = text;

    if (!isInit) {
      $target.appendChild($button);

      $button.addEventListener('click', () => {
        if ($button.style.textDecoration === 'line-through') {
          button.style.textDecoration = 'none';
        } else {
          button.style.textDecoration = 'line-through';
        }
      });

      isInit = true;
    }
  };

  this.render();
}

const $app = document.querySelector('body');

new ToggleButton({ $target: $app, text: 'Button1' });
new ToggleButton({ $target: $app, text: 'Button2' });
new ToggleButton({ $target: $app, text: 'Button3' });
new ToggleButton({ $target: $app, text: 'Button4' });
```

이렇게 토글버튼은 이 버튼을 그릴 target과 버튼의 이름만 잘 받으면 다른 로직은 신경쓰지 않고 버튼을 만들 수 있다. 그럼 몇 가지 기능을 더 추가해보자!

<br>

## 버튼을 3번 째 눌렀을 때 alert 창 띄우기

```js
function ToggleButton({ $target, text }) {
  const $button = document.createElement('button');
  let isInit = false;
  let clickCount = 0;

  this.render = () => {
    $button.textContent = text;

    if (!isInit) {
      $target.appendChild($button);

      $button.addEventListener('click', () => {
        clickCount += 1;

        if ($button.style.textDecoration === 'line-through') {
          button.style.textDecoration = 'none';
        } else {
          button.style.textDecoration = 'line-through';
        }

        if (clickCount % 3 === 0) {
          alert('3번 째 클릭');
        }
      });

      isInit = true;
    }
  };

  this.render();
}

const $app = document.querySelector('body');

new ToggleButton({ $target: $app, text: 'Button1' });
new ToggleButton({ $target: $app, text: 'Button2' });
new ToggleButton({ $target: $app, text: 'Button3' });
new ToggleButton({ $target: $app, text: 'Button4' });
```

<br>

간단히 ToggleButton 컴포넌트에 `clickCount` 변수를 선언하고 그에 따라 로직을 작성하면 된다. (만약 명령형으로 작성했다면 버튼이 추가될 때 마다 버튼별 count 변수를 선언하고 로직도 처리해야 하기 때문에 비효율적일것이다.)

하지만 위에 작성한 ToggleButton는 새로 생성되는 버튼 마다 강제로 `버튼을 3번 째 눌렀을 때 마다 alert 창 띄우기` 로직을 가지고 있게 된다.

버튼 별 click 로직을 다르게 하고싶으면 어떻게 하면 될까? 바로 ToggleButton에 원하는 동작을 하는 함수를 주입받아 실행하는 식으로 하여 의존성을 없앨 수 있다.

<br>

```js
function ToggleButton({ $target, text, onClick }) {
  const $button = document.createElement('button');
  let isInit = false;
  let clickCount = 0;

  this.render = () => {
    $button.textContent = text;

    if (!isInit) {
      $target.appendChild($button);

      $button.addEventListener('click', () => {
        clickCount += 1;

        if ($button.style.textDecoration === 'line-through') {
          button.style.textDecoration = 'none';
        } else {
          button.style.textDecoration = 'line-through';
        }

        if (onClick && typeof onClick === 'function') {
          onClick(clickCount);
        }
      });

      isInit = true;
    }
  };

  this.render();
}

const $app = document.querySelector('body');

new ToggleButton({
  $target: $app,
  text: 'Button1',
  onClick: clickCount => {
    if (clickCount % 3 === 0) {
      alert('3번째 클릭!!');
    }
  },
});
new ToggleButton({ $target: $app, text: 'Button2' });
new ToggleButton({ $target: $app, text: 'Button3' });
new ToggleButton({ $target: $app, text: 'Button4' });
```

<br>

이렇게 onClick을 따로 받을 수 있게 구현하면 원하는에 해당 로직을 추가할 수 있게 된다. 일단 지금까지 봤을 때 큰 문제는 없어보인다. 하지만 분명 더 개선할 점이 남아 있는데 특히 ToggleButton 컴포넌트의 주요 로직은 `$button.style.textDecoration`의 상태에 따라 나누어진다. 그렇기 때문에 이 부분도 항목이 더 많아지면 많아질 수록 복잡해 질 것이다.

그럼 어떻게 하는것이 좋은 방법이냐! 컴포넌트별 상태를 따로 관리하고 그 상태에 따라 `render` 함수에서 처리하도록 하면 된다. 말로 하면 이해가 잘 안될 수도 있으니 코드로 바로 보자!

<br>

```js
function ToggleButton({ $target, text, onClick }) {
  const $button = document.createElement('button');

  $target.appendChild($button);

  this.state = {
    clickCount: 0,
    toggled: false,
  };

  $button.addEventListener('click', () => {
    this.setState({
      clickCount: this.state.clickCount + 1,
      toggled: !this.state.toggled,
    });

    if (onClick && typeof onClick === 'function') {
      onClick(this.state.clickCount);
    }
  });

  this.setState = nextState => {
    this.state = nextState;
    this.render();
  };

  this.render = () => {
    $button.textContent = text;
    $button.style.textDecoration = this.state.toggled ? 'line-through' : 'none';
  };

  this.render();
}

const $app = document.querySelector('body');

new ToggleButton({
  $target: $app,
  text: 'Button1',
  onClick: clickCount => {
    if (clickCount % 3 === 0) {
      alert('3번째 클릭!!');
    }
  },
});
new ToggleButton({ $target: $app, text: 'Button2' });
new ToggleButton({ $target: $app, text: 'Button3' });
new ToggleButton({ $target: $app, text: 'Button4' });
```

<br>

위 코드를 보면 `setState` 메소드와 `state` 객체가 추가되었고 `render` 메소드에서는 각 `state`에 따라 흘러가도록 하고 있기 때문에 상태만 신경 쓰면 그에 맞게 알아서 렌더링 될 것이다!

<br>

## 5초 뒤에 토글되는 TimerButton

<br>

위에서 만들었던 ToggleButton을 확장하여 사용하는 `TimerButton`을 만들어 보자!

<br>

```js
// ... ToggleButton 생략
function TimerButton({ $target, text, timer = 5000 }) {
  const button = new ToggleButton({
    $target,
    text,
    onClick: () => {
      setTimeout(() => {
        button.setState({
          ...button.state,
          toggled: !button.state.toggled,
        });
      }, timer);
    },
  });
}

new TimerButton({ $target: $app, text: '타이머 토글 버튼', timer: 5000 });
```

<br>

잘 만들어진 ToggleButton을 확장해서 TimerButton을 만들었다. 이렇게 추상화를 잘 해놓으면 확장하기에 매우 쉽다!

<br>

## Button Group 만들기

<br>

위에 코드는 버튼을 하나하나 만들었는데 버튼을 그룹지어 만들 수 있는 컴포넌트를 작성해보자!

<br>

```js
function ButtonGroup({ $target, buttons }) {
  const $group = document.createElement('div');
  let isInit = false;

  this.render = () => {
    if (!isInit) {
      buttons.forEach(({ type, ...props }) => {
        if (type === 'toggle') {
          new ToggleButton({ $target: $group, ...props });
        } else if (type === 'timer') {
          new TimerButton({ $target: $group, ...props });
        }
      });

      $target.appendChild($group);
      isInit = true;
    }
  };

  this.render();
}

new ButtonGroup({
  $target: $app,
  buttons: [
    {
      type: 'toggle',
      text: '토글 버튼1',
    },
    {
      type: 'toggle',
      text: '토글 버튼2',
    },
    {
      type: 'timer',
      text: '타이머 버튼',
      timer: 2000,
    },
  ],
});
```

<br>

이렇게 구현함으로써 ButtonGroup 컴포넌트에 `buttons`의 내부 데이터만 생각해서 인자로 넘겨주면 내부에서 알아서 렌더링 해 준다! 그럼 당연히 재사용성도 좋아질 것이다.

선언적인 방식으로 사고를 바꿔보자!
