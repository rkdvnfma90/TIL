# SPA 란?

<br>

`Single Page Application`을 알기 위해선 기본적으로 웹이 어떻게 돌아가는지 알아야 한다. 아래 설명들을 통해 하나씩 이해하며 SPA가 무엇인지 알아가보자

<br>

## 정적인 웹 페이지

<br>

- HTML 파일들로 페이지가 구성된다
- url이 파일 경로와 이름이 된다
- url상 파일명이 없을경우 index.html을 찾는다
- 페이지를 이동할 때 마다 해당 페이지의 html 파일을 내려받아 보여준다

<br>

## 웹 애플리케이션

<br>

- 정적인 파일을 웹 서버로 제공하는 방식뿐만 아니라 PHP, Java, Node.js를 이용하여 동적으로 HTML을 생성해서 제공하는 방식
- 즉, 서버에서 HTML을 생성해서 내려주는 방식
- 물리적으로 파일을 내려주는 것이 아니라 서버에서 어떠한 로직을 타고 HTML을 동적으로 생성하여 내려준다
- 문제점은 HTML을 서버에서 만들어서 내려주고 그 이후 동작은 Javascript가 하다보니 렌더링 시점이 뒤죽박죽이 될 수 있다
- 그러다보니 서버 렌더링 시점에서 구현했던 것을 클라이언트에서 동적으로 렌더링 해야한다면 클라이언트 쪽에서도 같은 로직을 중복해서 구현해야 하는 상황이 있다
- 궁극적으로 유저 인터렉션 (이벤트 바인딩 등등)처리를 클라이언트 사이드에서 해야하기 때문에 모든 처리를 서버에서 할 수 없다 (서버에선 마크업만 내려줄 뿐)

<br>

## Single Page Application (SPA)

<br>

- 서버는 API만 처리하고 모든 렌더링은 클라이언트 사이드에서 하는 방식
- 클라이언트의 html파일은 `index.html`하나만 존재하고 클라이언트로 오는 모든 url 요청을 index.html로 돌린다
- 정리하자면 `product/1` 이라는 url로 요청이 와도 `index.html`이 처리하도록 하는 별도의 로직이 필요하다.
- 이후 동작은 url을 보고 어떤 페이지를 그릴지 동적으로 처리한다.
- 이전 방식은 페이지를 이동할 때 마다 모든 내용을 새로 불러와야 했지만, SPA는 렌더링만 다시 동적으로 하기 때문에 `첫 로딩 이후`에는 네트워크 부담이 줄어든다.

<br>

---

<br>

이제 본격적으로 SPA에 대해서 알아보자

<br>

## hashbang

<br>

SPA에서 어떤 페이지를 그릴지 구분하는 방법중에 `hashbang`이라는 것이 있다. 이것은 `url 맨 뒤에 #(해시)을 이용해 처리하는 방법`이다. 보통 이 해시는 같은 페이지 내에 요소를 가리킬 때 많이 사용되었다. (스크롤이 원하는 타겟으로 이동)

- localhost:5000/
- localhost:5000/#list
- localhost:5000/#qna

위의 이 url은 모두 같은 index.html을 불러오며 뒤에 붙은 해시는 `location.hash`를 통해 가져올 수 있다. 정리하자면 hashbang은 `해시를 통해 어떤 페이지를 렌더링할지 정하는 로직을 따로 구현`해서 쓰는 방법이다.

그럼 해시가 동적으로 변경되었을 때를 어떻게 감지할 수 있을까? 바로 window에 `hashchange` 이벤트 리스너를 사용하여 감지할 수 있다.

### `hashbang`의 단점

- 해시를 써야하기 때문에 url에서 `queryString`이나 `params`를 쓰기 조금 까다로워 질 수 있다.
- 해시가 붙어있기 때문에 우리가 흔히 알고있는 url의 형태와 약간 다르다.

<br>

### `hashbang`의 장점

- `history API`를 제대로 지원하지 않는 옛날 브라우저에서도 SPA를 구현할 수 있다. (하지만 요즘은 거의 모던 브라우저를 사용하기 때문에 hashbang은 많이 쓰이지 않는다.)

<br>

## history API

<br>

- 브라우저에서 페이지 로딩을 하면 세션 히스토리라는 것을 가지고 있다.
- 세션 히스토리는 페이지를 이동할 때 마다 쌓이게 되며, 이것을 통해 뒤로 가기, 앞으로 가기 등을 통해 페이지 이동이 가능하다.
- `pushSate`, `replaceState` 두 개의 함수를 통해 화면 이동없이 현재 url을 업데이트 할 수 있다.
  - pushState : 세션 히스토리에 새 url을 쌓는다.
  - replaceState : 세션 히스토리에 새 url을 쌓지않고 현재 url을 대체한다. (뒤로가기 하면 안되는 상황에 씀, 보통 form 처리하고나서 서버에 전송 후 완료 페이지로 이동했는데 다시 뒤로가서 전송하면 안되기 때문)
- hashbang의 `hashchange`이벤트 처럼 `popstate` 이벤트로 세션 히스토리의 변경을 감지할 수 있다.
- **유의할 점은 `popstate` 이벤트는 `history.go`나 `history.back`을 할 때 발생한다!!**

<br>

### history.pushState

- history.pushState(`state`, `title`, `url`)
  - state : 다음으로 이동할 url에 값을 전달 (JSON의 형태), `history.state`로 꺼내 쓸 수 있다.
  - title : 변경될 페이지의 title을 가리키는 값인 것 같지만 거의 대부분 브라우저에서 지원하지 않는다. 그래서 아직은 빈 string을 넣어주자
  - url : 세션 히스토리에 새로 넣을 url이다. a태그를 클릭하거나 location.href로 url을 변경하는 것과 다르게 이것이 변경된다고 해서 화면이 리로드 되지 않는다.

<br>

### history.replaceState

- history.replaceState(`state`, `title`, `url`)
  - url : 세션 히스토리에서 현재 url과 대체할 url이다.
  - 나머지 속성은 pushState와 동일하다.

---

<br>

history API를 사용할 경우 hashbang과는 다르게 `a 태그`를 그대로 사용하면 의도한대로 동작하지 않는다. 그 이유는 a 태그의 기본동작이 href에 연결된 url로 `이동`하기 때문이다. history API에서 SPA처리를 하려면 이동이 아니라 바뀌는 요소만 `렌더링` 해야 하기 때문이다.

> 만약 SPA로 구현한 사이트에서 `localhost:5000/list`의 경로에 접속해 있고 이 상태에서 새로고침을 눌렀을 때 별도의 처리(`어떠한 url이 와도 index.html이 처리하도록`)를 하지 않으면 404 에러가 발생할 것이다. (브라우저 입장에선 `list.html`을 찾아야 하는데 없기 때문)
